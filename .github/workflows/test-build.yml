name: Build, Test and Push

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the develop and master branches
on:
  pull_request:
    branches: [develop, master]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  test-unit:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [12.x]

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}

      - name: Cache node_modules
        uses: actions/cache@v2
        env:
          cache-name: ${{ matrix.node-version }}-cache-node-modules
        with:
          path: ~/.npm
          key: ${{ runner.os }}-${{ env.cache-name }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.cache-name }}-

      - run: npm ci --loglevel error --no-fund
      - run: npm run build
      - run: npm test
        env:
          NODE_ENV: test
          secret: ${{secrets.secret}}
          tokenLife: 7d
          SPARKPOST_TOKEN: wrong_token_for_test

    test-integration:
      runs-on: ubuntu-latest

      steps:
        - uses: actions/checkout@v2

        - name: Login to GitHub Packages Docker Registry
          uses: docker/login-action@v1
          with:
            registry: docker.pkg.github.com
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}

        - name: Load app cache
          id: cached-image
          uses: actions/cache@v2
          with:
            path: |
              /tmp/.buildx-layer-cache
              /tmp/.buildx-image-cache
            key: ${{ runner.os }}-buildx-${{ github.head_ref }}-${{ github.sha }}

        - name: Fail on app cache miss
          if: steps.cached-image.outputs.cache-hit != 'true'
          run: |
            echo "No cache hit!"
            exit 1

        - name: Load cached app image
          run: |
            docker load --input /tmp/.buildx-image-cache/img.tar

        - name: Resolve required repositories
          id: resolve_rep
          run: |
            # this assumes the result is an array, and .name property is used
            check_feature() {
              # first param is the branch, everything after is endpoint for curl
              local branch=$1
              local found=0

              shift

              for endpoint in $@; do
                local json=$(curl -s $endpoint)
                local branch_found=$(echo $json | jq -c ".[] | select(.name==\"$branch\") | .name")

                # to track what we found
                echo "$endpoint -> $branch_found" &> /dev/stderr

                if [[ $branch_found != "" ]]; then
                  found=$((found += 1))
                fi
              done

              echo $found
            }

            BE_TAGS=$(check_feature ${{ github.head_ref }} \
              https://registry.hub.docker.com/v1/repositories/dmsc/duo-backend/tags \
              https://api.github.com/repos/UserOfficeProject/user-office-backend/branches
            )

            BE_TAG=develop
            if [[ $BE_TAGS == "2" ]]; then
              BE_TAG="${{ github.head_ref }}"
            fi

            echo ::set-output name=BE_TAG::$REPO_DIR_NAME

        - name: Download required repositories
          run: |
            cd "$GITHUB_WORKSPACE/.."
            git clone --depth 1 --branch "$REPO_DIR_NAME" https://github.com/UserOfficeProject/user-office-backend.git

        - name: Setup base docker-compose
          run: |
            cd "$GITHUB_WORKSPACE/.."
            cat > docker-compose.all.yml << EOF
            version: "3.1"
            EOF

        - name: Run docker-compose
          run: |
            cd "$GITHUB_WORKSPACE/.."

            REPO_DIR_NAME=$(basename $GITHUB_WORKSPACE)

            export USER_OFFICE_BACKEND_TAG=${{ steps.resolve_rep.outputs.BE_TAG }}
            export USER_OFFICE_BACKEND_DIR=$REPO_DIR_NAME

            docker-compose -f docker-compose.all.yml \
              -f $REPO_DIR_NAME/docker-compose.integration.yml \
              up

  build:
    runs-on: ubuntu-latest
    needs: [test-unit, test-integration]

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Cache app docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-layer-cache
          key: ${{ runner.os }}-buildx-${{ github.head_ref }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ github.head_ref }}-
            ${{ runner.os }}-buildx-

      - name: Login to DockerHub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # For debugging capture the selected branch
      - name: Extracted branch
        run: echo "Extracted branch ${{ github.head_ref }}"

      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          push: true
          tags: dmsc/duo-backend:${{ github.head_ref }}
          cache-from: type=local,src=/tmp/.buildx-layer-cache
          cache-to: type=local,mode=max,dest=/tmp/.buildx-layer-cache
